// ============================================================================
//   Ver  :| Author					:| Mod. Date :| Changes Made:
//   V1.1 :| Alexandra Du			:| 06/01/2016:| Added Verilog file
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`define ENABLE_ADC_CLOCK
`define ENABLE_CLOCK1
`define ENABLE_CLOCK2
`define ENABLE_SDRAM
`define ENABLE_HEX0
`define ENABLE_HEX1
`define ENABLE_HEX2
`define ENABLE_HEX3
`define ENABLE_HEX4
`define ENABLE_HEX5
`define ENABLE_KEY
`define ENABLE_LED
`define ENABLE_SW
`define ENABLE_VGA
`define ENABLE_ACCELEROMETER
`define ENABLE_ARDUINO
`define ENABLE_GPIO

module DE10_LITE_Golden_Top(

	//////////// ADC CLOCK: 3.3-V LVTTL //////////
`ifdef ENABLE_ADC_CLOCK
	input 		          		ADC_CLK_10,
`endif
	//////////// CLOCK 1: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK1
	input 		          		MAX10_CLK1_50,
`endif
	//////////// CLOCK 2: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK2
	input 		          		MAX10_CLK2_50,
`endif

	//////////// SDRAM: 3.3-V LVTTL //////////
`ifdef ENABLE_SDRAM
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,
`endif

	//////////// SEG7: 3.3-V LVTTL //////////
`ifdef ENABLE_HEX0
	output		     [7:0]		HEX0,
`endif
`ifdef ENABLE_HEX1
	output		     [7:0]		HEX1,
`endif
`ifdef ENABLE_HEX2
	output		     [7:0]		HEX2,
`endif
`ifdef ENABLE_HEX3
	output		     [7:0]		HEX3,
`endif
`ifdef ENABLE_HEX4
	output		     [7:0]		HEX4,
`endif
`ifdef ENABLE_HEX5
	output		     [7:0]		HEX5,
`endif

	//////////// KEY: 3.3 V SCHMITT TRIGGER //////////
`ifdef ENABLE_KEY
	input 		     [1:0]		KEY,
`endif

	//////////// LED: 3.3-V LVTTL //////////
`ifdef ENABLE_LED
	output		     [9:0]		LEDR,
`endif

	//////////// SW: 3.3-V LVTTL //////////
`ifdef ENABLE_SW
	input 		     [9:0]		SW,
`endif

	//////////// VGA: 3.3-V LVTTL //////////
`ifdef ENABLE_VGA
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,
`endif

	//////////// Accelerometer: 3.3-V LVTTL //////////
`ifdef ENABLE_ACCELEROMETER
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,
`endif

	//////////// Arduino: 3.3-V LVTTL //////////
`ifdef ENABLE_ARDUINO
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,
`endif

	//////////// GPIO, GPIO connect to GPIO Default: 3.3-V LVTTL //////////
`ifdef ENABLE_GPIO
	inout 		    [35:0]		GPIO
`endif
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
// for instructions
// instruction => 31 - 25 --- 24 - 20 --- 19 - 15 --- 14 - 12 --- 11 - 7 --- 6 - 0
//  reg-reg        func7        rs2          rs1        func3      rd        opcode
//  one immediate       imm[11:0]			   rs1        func3      rd        opcode
//    load					imm[11:0]				rs1		  func3		 rd		  opcode
//    store			imm[11:5]	  rs2				rs1		  func3	  imm[4:0]	  opcode
//     branch   imm[12|10:5]	  rs2				rs1		  func3	 imm[4:1|11]  opcode


parameter integer controlBit = 26;
wire [31:0] instruction, signedI, signedS, signedB, signedJ, signedU;
wire [31:0] pc;
wire [2:0] instruc_count;
wire instruc_count_reset, branch;
wire [31:0]port1, port2, aluOut, wD, port2True, port1True, br_imm, MD;
wire [controlBit -1:0] controlWord;

wire valid1, valid2, start;
wire [7:0] inst_data, address, prog, inst_b;

wire [31:0] test_output;
wire [7:0] test_output2;

//=======================================================
//  Structural coding
//=======================================================
//-- controlWord	25-21		20-19		18-17		16-14		13-11		10		9-7	6		5		4 - 0
//-- meaning		custom	p1sel		brImmsel	brFunc	wDsel		MRW	p2sel	pcEn  wREn  aluFunc

//  port (
//    i_Clk       : in  std_logic;
//    i_TX_DV     : in  std_logic;
//    i_TX_Byte   : in  std_logic_vector(7 downto 0);
//    o_TX_Active : out std_logic;
//    o_TX_Serial : out std_logic;
//    o_TX_Done   : out std_logic
//    );
//end UART_TX;
UART_TX tx(.i_Clk(ADC_CLK_10), .i_TX_DV(SW[9]), .i_TX_Byte(SW[8:1]), .o_TX_Serial(GPIO[1]));


UART_RX rx (.i_Clk(ADC_CLK_10), .i_RX_Serial(GPIO[0]), .o_RX_Byte(inst_data), .o_RX_DV(valid1), .o_RX_DV2(valid2));

program program0 (.reset(KEY[1]), .valid1(valid1), .valid2(valid2), .data(inst_data), .dataOut(inst_b), .address(address), .program(prog));
start_exc start_exc0 (.reset(KEY[1]), .key(KEY[0]), .start(start));
instruction_reg u3 (.reset(KEY[1]), .inst(instruction), .pc(pc), .clk_in(ADC_CLK_10), .address(address), .data(inst_b), .program(valid2), .start(start), .test_data(test_output2));

counter u1 (.clk_in(ADC_CLK_10), .count(instruc_count), .counter_reset(instruc_count_reset));
PC u2 (.reset(KEY[1]), .pc_clk(ADC_CLK_10), .pc(pc), .instruc_count_reset(instruc_count_reset), .pcEn(controlWord[6]), .br_offset(br_imm), .branch(branch), .pcMode({1'b0,controlWord[18:17]}));

register_file u4(.reset(KEY[1]), .wAddr(instruction[11:7]), .rAddr1(instruction[19:15]), .rAddr2(instruction[24:20]), .clk_in(ADC_CLK_10), .port1(port1), .port2(port2), .wEn(controlWord[5]), .wD(wD), .test_out(test_output));
control_unit #(.controlBit(controlBit)) u5 (.opcode(instruction[6:0]), .func7(instruction[31:25]), .counter(instruc_count), .func3(instruction[14:12]), .clk_in(ADC_CLK_10), .controlWord(controlWord));
alu u6 (.port1(port1True), .port2(port2True), .aluFunc(controlWord[4:0]), .brFunc(controlWord[16:14]), .branch(branch), .aluOut(aluOut));
signExtend u7 (.a(instruction[31:20]), .signExtended(signedI));
alu_p2_mux u8 (.a(port2), .b(signedI), .c(signedS), .d(signedB), .e(signedU), .sel({controlWord[9:7]}), .muxOut(port2True));
reg_file_wD_mux u9 (.a(pc), .b(aluOut), .c(MD), .d(signedU), .sel(controlWord[13:11]), .muxOut(wD));
data_mem u10 (.clk_in(ADC_CLK_10), .wrAddr(aluOut), .MRW(controlWord[10]), .rD(MD), .wD(port2));
signExtend u11 (.a({instruction[31:25], instruction[11:7]}), .signExtended(signedS));
signExtend #(.number_bit(32), .fromExtend(13), .toExtend(32)) u12 (.a({instruction[31], instruction[7],instruction[30:25], instruction[11:8], 1'b0}), .signExtended(signedB));
signExtend #(.number_bit(32), .fromExtend(21), .toExtend(32)) u13 (.a({instruction[31], instruction[19:12],instruction[20], instruction[30:21], 1'b0}), .signExtended(signedJ));
br_imm_mux u14 (.a(signedB), .b(signedJ), .c(aluOut), .sel({1'b0,controlWord[18:17]}), .muxOut(br_imm));
alu_p1_mux u15 (.a(port1), .b(pc), .sel(controlWord[20:19]), .muxOut(port1True));
signExtend #(.number_bit(32), .fromExtend(20), .toExtend(32), .shift(12)) u16 (.a(instruction[31:12]), .signExtended(signedU));


debug_output debugOut (.data1(port1), .data2(port2), .en(controlWord[23]), .sel(controlWord[22:21]), .clk_in(ADC_CLK_10), .debugOut({GPIO[23:2],LEDR[9:0]}));

//assign LEDR[7:0] = test_output[7:0];
assign HEX0 = test_output2;
endmodule
